// Generated by CoffeeScript 1.7.1
(function() {
  var math,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  define("revigred.controller", [], function() {
    var controller, models, views;
    views = namespace("revigred.views");
    models = namespace("revigred.models");
    controller = namespace("revigred.controller");
    controller.Controller = (function() {
      function Controller(options) {
        this._node_views = {};
        this._connector_views = {};
        this.graph = options.graph;
      }

      Controller.prototype.get_node_view = function(node) {
        var _base, _name;
        return (_base = this._node_views)[_name = node.id] != null ? _base[_name] : _base[_name] = new views.NodeView({
          model: node
        });
      };

      return Controller;

    })();
  });

  define('revigred.gizmos', [], function() {
    var Math;
    Math = namespace('Math');
    this.Gizmo = (function() {
      function Gizmo() {}

      return Gizmo;

    })();
    return this.EdgeGizmo = (function(_super) {
      var _debug;

      __extends(EdgeGizmo, _super);

      _debug = true;

      function EdgeGizmo(connector1, connector2) {
        this.connector1 = connector1;
        this.connector2 = connector2;
      }

      EdgeGizmo.getControlPoints = function(v0, v1, v2, t) {
        var d01, d12, fa, fb;
        d01 = v1.distance(v0);
        d12 = v2.distance(v1);
        fa = t * d01 / (d01 + d12);
        fb = t * d12 / (d01 + d12);
        return [v1.shift(-fa * (v2.x - v0.x), -fa * (v2.y - v0.y)), v1.shift(+fb * (v2.x - v0.x), +fb * (v2.y - v0.y))];
      };

      EdgeGizmo.drawDir = function(ctx, connector, v) {
        var bounds, c, center, cp, cur, dir, edge, height, i, next, path, points, pos, s_dl, s_dr, s_ul, s_ur, start, width, _i, _j, _ref, _ref1, _results;
        pos = connector.pos();
        start = pos.v1;
        edge = new math.Segment(start, v);
        bounds = connector.node.bounds();
        width = bounds.width;
        height = bounds.height;
        center = bounds.center;
        c = 0.7;
        points = [];
        s_ur = center.shift(+width * c, -height * c);
        s_dr = center.shift(+width * c, +height * c);
        s_ul = center.shift(-width * c, -height * c);
        s_dl = center.shift(-width * c, +height * c);
        if (edge.intersect(s_ur)) {
          points.push(s_ur.v2);
        }
        if (edge.intersect(s_dr)) {
          points.push(s_dr.v2);
        }
        if (edge.intersect(s_ul)) {
          points.push(s_ul.v2);
        }
        if (edge.intersect(s_dl)) {
          points.push(s_dl.v2);
        }
        points.forEach(function(p) {
          return p.metric = start.distance(p);
        });
        points = points.sort(function(a, b) {
          return a.metric - b.metric;
        });
        if (points.length > 2) {
          points = [points[0], points[points.length - 1]];
        }
        points.unshift(start);
        points.push(v);
        ctx.moveTo(pos.v1.x, pos.v1.y);
        path = [pos];
        if (points.length > 2) {
          for (i = _i = 2, _ref = points.length - 1; 2 <= _ref ? _i <= _ref : _i >= _ref; i = 2 <= _ref ? ++_i : --_i) {
            cp = this.getControlPoints(points[i - 2], points[i - 1], points[i], 0.5);
            path.push.apply(path, cp);
          }
        }
        dir = new math.Vector(start.x - v.x, start.y - v.y).normalize();
        path.push(v.shift(dir.x * 50, dir.y * 50));
        _results = [];
        for (i = _j = 0, _ref1 = path.length - 1; _j <= _ref1; i = _j += 2) {
          cur = path[i];
          next = path[i + 1];
          _results.push(ctx.bezierCurveTo(cur.v2.x, cur.v2.y, next.v2.x, next.v2.y, next.v1.x, next.v1.y));
        }
        return _results;
      };

      EdgeGizmo.prototype.makepath = function(pos1, pos2) {
        var bounds1, bounds2, c, center1, center2, cp, d, edge, end, height1, height2, i, path, points, s_dl1, s_dl2, s_dr1, s_dr2, s_ul1, s_ul2, s_ur1, s_ur2, same_node, start, width1, width2, _i, _ref;
        if (this._debug) {
          pos1.draw(ctx);
        }
        if (this._debug) {
          pos2.draw(ctx);
        }
        start = pos1.v1;
        end = pos2.v1;
        edge = new math.Segment(start, end);
        if (this._debug) {
          edge.draw(ctx);
        }
        bounds1 = this.connector1.node.bounds();
        width1 = bounds1.width;
        height1 = bounds1.height;
        center1 = bounds1.center;
        if (this._debug) {
          bounds1.draw(ctx);
        }
        bounds2 = this.connector2.node.bounds();
        width2 = bounds2.width;
        height2 = bounds2.height;
        center2 = bounds2.center;
        if (this._debug) {
          bounds2.draw(ctx);
        }
        same_node = this.connector1.node === this.connector2.node;
        if (same_node) {
          c = 0.7;
        } else {
          d = Math.sqrt(width1 * width1 + height1 * height1) + Math.sqrt(width2 * width2 + height2 * height2);
          c = Math.min(1 + d, edge.length) / d;
        }
        points = [];
        s_ur1 = center1.shift(+width1 * c, -height1 * c);
        s_dr1 = center1.shift(+width1 * c, +height1 * c);
        s_ul1 = center1.shift(-width1 * c, -height1 * c);
        s_dl1 = center1.shift(-width1 * c, +height1 * c);
        if (edge.intersect(s_ur1)) {
          points.push(s_ur1.v2);
        }
        if (edge.intersect(s_dr1)) {
          points.push(s_dr1.v2);
        }
        if (edge.intersect(s_ul1)) {
          points.push(s_ul1.v2);
        }
        if (edge.intersect(s_dl1)) {
          points.push(s_dl1.v2);
        }
        if (this._debug) {
          s_ur1.draw(ctx);
        }
        if (this._debug) {
          s_dr1.draw(ctx);
        }
        if (this._debug) {
          s_ul1.draw(ctx);
        }
        if (this._debug) {
          s_dl1.draw(ctx);
        }
        if (!same_node) {
          s_ur2 = center2.shift(+width2 * c, -height2 * c);
          s_dr2 = center2.shift(+width2 * c, +height2 * c);
          s_ul2 = center2.shift(-width2 * c, -height2 * c);
          s_dl2 = center2.shift(-width2 * c, +height2 * c);
          if (edge.intersect(s_ur2)) {
            points.push(s_ur2.v2);
          }
          if (edge.intersect(s_dr2)) {
            points.push(s_dr2.v2);
          }
          if (edge.intersect(s_ul2)) {
            points.push(s_ul2.v2);
          }
          if (edge.intersect(s_dl2)) {
            points.push(s_dl2.v2);
          }
          if (this._debug) {
            s_ur2.draw(ctx);
          }
          if (this._debug) {
            s_dr2.draw(ctx);
          }
          if (this._debug) {
            s_ul2.draw(ctx);
          }
          if (this._debug) {
            s_dl2.draw(ctx);
          }
        }
        points.forEach(function(p) {
          return p.metric = start.distance(p);
        });
        points = points.sort(function(a, b) {
          return a.metric - b.metric;
        });
        if (points.length > 2) {
          points = [points[0], points[points.length - 1]];
        }
        points.unshift(start);
        points.push(end);
        path = [pos1];
        if (points.length > 2) {
          for (i = _i = 2, _ref = points.length - 1; 2 <= _ref ? _i <= _ref : _i >= _ref; i = 2 <= _ref ? ++_i : --_i) {
            cp = EdgeGizmo.getControlPoints(points[i - 2], points[i - 1], points[i], 0.5);
            path.push.apply(path, cp);
          }
        }
        path.push(pos2);
        return path;
      };

      EdgeGizmo.prototype.draw = function(ctx) {
        var bounds, cur, i, next, pos1, pos2, rect, _i, _ref;
        pos1 = this.connector1.pos();
        pos2 = this.connector2.pos();
        if (!((this._p1 != null) && (this._p2 != null) && this._p1.equals(pos1) && this._p2.equals(pos2))) {
          this.path = this.makepath(pos1, pos2);
        }
        this._p1 = pos1;
        this._p2 = pos2;
        bounds = null;
        ctx.moveTo(pos1.v1.x, pos1.v1.y);
        for (i = _i = 0, _ref = this.path.length - 1; _i <= _ref; i = _i += 2) {
          cur = this.path[i];
          next = this.path[i + 1];
          ctx.bezierCurveTo(cur.v2.x, cur.v2.y, next.v2.x, next.v2.y, next.v1.x, next.v1.y);
          rect = Math.bezierCurveBounds(cur.v1, cur.v2, next.v2, next.v1);
          if (bounds === null) {
            bounds = rect;
          } else {
            bounds = bounds.union(rect);
          }
        }
        if (this._debug) {
          return bounds.draw(ctx);
        }
      };

      return EdgeGizmo;

    })(this.Gizmo);
  });

  define([], function() {
    var math, _base;
    math = namespace('Math');
    if ((_base = Function.prototype).property == null) {
      _base.property = function(prop, desc) {
        return Object.defineProperty(this.prototype, prop, desc);
      };
    }
    math.Vector = (function() {
      function Vector(x, y) {
        this.x = x;
        this.y = y;
      }

      Vector.prototype.equals = function(v) {
        return this.x === v.x && this.y === v.y;
      };

      Vector.prototype.distance = function(v) {
        var a, b;
        a = this.x - v.x;
        b = this.y - v.y;
        return Math.sqrt(a * a + b * b);
      };

      Vector.prototype.shift = function(dx, dy) {
        return new math.Segment(this, new math.Vector(this.x + dx, this.y + dy));
      };

      Vector.prototype.size = function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      };

      Vector.prototype.normalize = function() {
        var size;
        size = this.size();
        return new math.Vector(this.x / size, this.y / size);
      };

      return Vector;

    })();
    math.Line = (function() {
      function Line(a, b, c) {
        var m;
        m = (c > 0 ? -1 : 1) / Math.sqrt(a * a + b * b);
        this.A = a * m;
        this.B = b * m;
        this.C = c * m;
      }

      Line.from_vectors = function(v1, v2) {
        return new this(v1.y - v2.y, v2.x - v1.x, v1.x * v2.y - v2.x * v1.y);
      };

      Line.prototype.distance = function(v) {
        return this.A * v.x + this.B * v.y + this.C;
      };

      return Line;

    })();
    math.Segment = (function() {
      function Segment(v1, v2) {
        this.v1 = v1;
        this.v2 = v2;
        this.line = math.Line.from_vectors(this.v1, this.v2);
      }

      Segment.prototype.equals = function(s) {
        return this.v1.equals(s.v1) && this.v2.equals(s.v2);
      };

      Segment.prototype.intersect = function(s) {
        var p1, p2, q1, q2;
        q1 = this.line.distance(s.v1);
        q2 = this.line.distance(s.v2);
        p1 = s.line.distance(this.v1);
        p2 = s.line.distance(this.v2);
        return q1 * q2 <= 0 && p1 * p2 <= 0;
      };

      Segment.prototype.draw = function(ctx) {
        ctx.moveTo(this.v1.x, this.v1.y);
        return ctx.lineTo(this.v2.x, this.v2.y);
      };

      Segment.property('length', {
        get: function() {
          return this._length != null ? this._length : this._length = this.v1.distance(this.v2);
        }
      });

      Segment.property('bounds', {
        get: function() {
          return this._bounds != null ? this._bounds : this._bounds = new math.Rect(this.v1, this.v2);
        }
      });

      return Segment;

    })();
    math.Rect = (function() {
      function Rect(x1, y1, x2, y2) {
        this.min_x = Math.min(x1, x2);
        this.min_y = Math.min(y1, y2);
        this.max_x = Math.max(x1, x2);
        this.max_y = Math.max(y1, y2);
        this.width = this.max_x - this.min_x;
        this.height = this.max_y - this.min_y;
      }

      Rect.prototype.equals = function(r) {
        return this.min_x === r.min_x && this.min_y === r.min_y && this.max_x === r.max_x && this.max_y === r.max_y;
      };

      Rect.property('tl', {
        get: function() {
          return this._tl != null ? this._tl : this._tl = new math.Vector(this.min_x, this.min_y);
        }
      });

      Rect.property('tr', {
        get: function() {
          return this._tr != null ? this._tr : this._tr = new math.Vector(this.max_x, this.min_y);
        }
      });

      Rect.property('br', {
        get: function() {
          return this._br != null ? this._br : this._br = new math.Vector(this.max_x, this.max_y);
        }
      });

      Rect.property('bl', {
        get: function() {
          return this._bl != null ? this._bl : this._bl = new math.Vector(this.min_x, this.max_y);
        }
      });

      Rect.property('center', {
        get: function() {
          return this._center != null ? this._center : this._center = new math.Vector((this.max_x + this.min_x) / 2, (this.max_y + this.min_y) / 2);
        }
      });

      Rect.prototype.contains = function(point) {
        var _ref, _ref1;
        return (this.min_x <= (_ref = point.x) && _ref <= this.max_x) && (this.min_y <= (_ref1 = point.y) && _ref1 <= this.max_y);
      };

      Rect.from_vectors = function(v1, v2) {
        return new this(v1.x, v1.y, v2.x, v2.y);
      };

      Rect.prototype.intersect = function(rect) {
        if (this.min_x > rect.max_x) {
          return false;
        }
        if (this.max_x < rect.min_x) {
          return false;
        }
        if (this.min_y > rect.max_y) {
          return false;
        }
        if (this.max_y < rect.min_y) {
          return false;
        }
        return true;
      };

      Rect.prototype.union = function(rect) {
        return new math.Rect(Math.min(this.min_x, rect.min_x), Math.min(this.min_y, rect.min_y), Math.max(this.max_x, rect.max_x), Math.max(this.max_y, rect.max_y));
      };

      Rect.prototype.draw = function(ctx) {
        ctx.moveTo(this.min_x, this.min_y);
        ctx.lineTo(this.max_x, this.min_y);
        ctx.lineTo(this.max_x, this.max_y);
        ctx.lineTo(this.min_x, this.max_y);
        return ctx.lineTo(this.min_x, this.min_y);
      };

      return Rect;

    })();
    math.bezierPolinom = function(a, b, c, d, t) {
      var k;
      k = 1 - t;
      return k * k * (k * a + 3 * t * b) + t * t * (3 * k * c + t * d);
    };
    math.bezierPoint = function(a, b, c, d, t) {
      return new math.Vector(math.bezierPolinom(a.x, b.x, c.x, d.x, t), math.bezierPolinom(a.y, b.y, c.y, d.y, t));
    };
    math.lerp = function(a, b, t) {
      return (1 - t) * a + t * b;
    };
    math.bezierCasteljau = function(a, b, c, d, t) {
      var p, q, r, s, u;
      p = math.lerp(a, b, t);
      q = math.lerp(b, c, t);
      r = math.lerp(c, d, t);
      s = math.lerp(p, q, t);
      u = math.lerp(q, r, t);
      return math.lerp(s, u, t);
    };
    return math.bezierCurveBounds = function(a, b, c, d) {
      var i, maxx, maxy, minx, miny, px, py, qx, qy, rx, ry, step, sx, sy, tobx, toby, tocx, tocy, todx, tody, toqx, toqy, torx, tory, totx, toty, tx, ty, x, y, _i;
      minx = miny = Number.POSITIVE_INFINITY;
      maxx = maxy = Number.NEGATIVE_INFINITY;
      tobx = b.x - a.x;
      toby = b.y - a.y;
      tocx = c.x - b.x;
      tocy = c.y - b.y;
      todx = d.x - c.x;
      tody = d.y - c.y;
      step = 1 / 40;
      for (i = _i = 0; _i <= 40; i = ++_i) {
        d = i * step;
        px = a.x + d * tobx;
        py = a.y + d * toby;
        qx = b.x + d * tocx;
        qy = b.y + d * tocy;
        rx = c.x + d * todx;
        ry = c.y + d * tody;
        toqx = qx - px;
        toqy = qy - py;
        torx = rx - qx;
        tory = ry - qy;
        sx = px + d * toqx;
        sy = py + d * toqy;
        tx = qx + d * torx;
        ty = qy + d * tory;
        totx = tx - sx;
        toty = ty - sy;
        x = sx + d * totx;
        y = sy + d * toty;
        minx = Math.min(minx, x);
        miny = Math.min(miny, y);
        maxx = Math.max(maxx, x);
        maxy = Math.max(maxy, y);
      }
      return new math.Rect(minx, miny, maxx, maxy);
    };
  });

  define(['Backbone.Model'], function() {
    var collections, delay, gizmos, models;
    models = namespace("revigred.models");
    collections = namespace("revigred.collections");
    gizmos = namespace("revigred.gizmos");
    delay = function(time, callback) {
      return window.setTimeout(callback, time);
    };
    models.EchoChannel = (function() {
      function EchoChannel(model) {
        this.model = model;
        this.id = "channel-" + uuid.v4();
        this.model.on("createNode", (function(_this) {
          return function(node) {
            return _this.createNode(node.id);
          };
        })(this));
      }

      EchoChannel.prototype.onNodeCreated = function(channelId, nodeId) {
        var node;
        console.log("onNodeCreated", channelId, nodeId);
        if (channelId === this.id) {
          node = this.model.get_node(nodeId);
        } else {
          node = new models.NodeModel({
            id: nodeId
          });
          this.model.add(node);
        }
        if (node != null) {
          node.set("local", false);
          node.on("change", (function(_this) {
            return function(node) {
              return _this.changeState(node.id, node.changedAttributes());
            };
          })(this));
        }
      };

      EchoChannel.prototype.onNodeStateChanged = function(channelId, nodeId, nodeState) {
        var node;
        console.log("onNodeStateChanged", channelId, nodeId, nodeState);
        if (channelId === this.id) {

        } else {
          node = this.model.get_node(nodeId);
        }
        return node != null ? node.set(nodeState) : void 0;
      };

      EchoChannel.prototype.onLinkAdded = function(nodeId1, portId1, nodeId2, portId2) {
        var node1, node2, port1, port2;
        node1 = this.model.get_node(nodeId1);
        port1 = node1 != null ? node1.get_connector(portId1) : void 0;
        node2 = this.model.get_node(nodeId2);
        port2 = node2 != null ? node2.get_connector(portId2) : void 0;
        if ((port1 != null) && (port2 != null)) {
          this.model.connect(port1, port2);
        }
      };

      EchoChannel.prototype.onPortsChanged = function(channelId, nodeId, inputs, outputs) {
        var connector, input, joined, node, output, _i, _j, _len, _len1;
        console.log("onPortsChanged", channelId, nodeId, inputs, outputs);
        node = this.model.get_node(nodeId);
        if (node != null) {
          joined = [];
          for (_i = 0, _len = inputs.length; _i < _len; _i++) {
            input = inputs[_i];
            connector = new models.InputConnectorModel(input);
            joined.push(connector);
            connector.set_node(node);
          }
          for (_j = 0, _len1 = outputs.length; _j < _len1; _j++) {
            output = outputs[_j];
            connector = new models.OutputConnectorModel(output);
            joined.push(connector);
            connector.set_node(node);
          }
          node.connectors.set(joined);
          console.log(node.connectors.toArray());
        }
      };

      EchoChannel.prototype.createNode = function(modelNodeId) {
        delay(1000, (function(_this) {
          return function() {
            return _this.onNodeCreated(_this.id, modelNodeId);
          };
        })(this));
      };

      EchoChannel.prototype.changeState = function(modelNodeId, nodeState) {
        delay(1000, (function(_this) {
          return function() {
            return _this.onNodeStateChanged(_this.id, modelNodeId, nodeState);
          };
        })(this));
      };

      return EchoChannel;

    })();
    models.GraphModel = (function(_super) {
      __extends(GraphModel, _super);

      function GraphModel(options) {
        GraphModel.__super__.constructor.call(this, options);
        this.nodes = new collections.NodesList();
        this.connections = new collections.ConnectionsList();
      }

      GraphModel.prototype.add = function() {
        var node, nodes, _i, _j, _len, _len1;
        nodes = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          node = nodes[_i];
          if (!isinstance(node, models.NodeModel, gizmos.Gizmo)) {
            throw "Invalid type";
          }
        }
        for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
          node = nodes[_j];
          if (isinstance(node, models.NodeModel)) {
            this.nodes.push(node);
            node.on("select", this.select, this);
            node.on("deselect", this.deselect, this);
            node.set_graph(this);
          }
        }
        return this;
      };

      GraphModel.prototype.get_node = function(id) {
        return this.nodes.get(id);
      };

      GraphModel.prototype.pick_start = function(start_connector) {
        this.start_connector = start_connector;
      };

      GraphModel.prototype.pick_end = function(end_connector) {
        if (this.start_connector != null) {
          if (this.start_connector !== end_connector) {
            this.connect(this.start_connector, end_connector);
          }
          this.drop_start();
        }
      };

      GraphModel.prototype.drop_start = function() {
        return this.start_connector = null;
      };

      GraphModel.prototype.connect = function(connector1, connector2) {
        var connection, connector;
        connector = this.connections.findWhere({
          start: connector1,
          end: connector2
        });
        if (connector != null) {
          return;
        }
        connection = new models.ConnectionModel({
          start: connector1,
          end: connector2
        });
        this.connections.push(connection);
      };

      GraphModel.prototype.disconnect = function(connector1, connector2) {
        var connector;
        connector = this.connections.findWhere({
          start: connection.connector1,
          end: connection.connector2
        });
        if (connector != null) {
          connector.destroy();
        }
      };

      GraphModel.prototype.select = function(node) {
        var _ref, _ref1;
        return (_ref = this.nodes) != null ? (_ref1 = _ref.selection) != null ? _ref1.add(node) : void 0 : void 0;
      };

      GraphModel.prototype.deselect = function(node) {
        var _ref, _ref1;
        return (_ref = this.nodes) != null ? (_ref1 = _ref.selection) != null ? _ref1.remove(node) : void 0 : void 0;
      };

      GraphModel.prototype.deselect_all = function() {
        var _ref, _ref1;
        return (_ref = this.nodes) != null ? (_ref1 = _ref.selection) != null ? _ref1.deselect_all() : void 0 : void 0;
      };

      GraphModel.prototype.create_node = function() {
        var node;
        node = new models.NodeModel();
        this.add(node);
        this.trigger("createNode", node);
        return node;
      };

      return GraphModel;

    })(Backbone.Model);
    models.NodeModel = (function(_super) {
      __extends(NodeModel, _super);

      NodeModel.prototype.defaults = {
        id: null,
        x: 100,
        y: 100,
        title: "NodeModel",
        local: true,
        selected: false
      };

      NodeModel.prototype.validation = {
        id: function(value, attr, computedState) {
          if (value == null) {
            return 'Name is invalid';
          }
        }
      };

      function NodeModel(options) {
        NodeModel.__super__.constructor.call(this, options);
        if ((options != null ? options.id : void 0) == null) {
          this.set("id", uuid.v4());
        }
        this.connectors = new collections.ConnectorsList();
      }

      NodeModel.prototype.get_connector = function(name) {
        return this.connectors.find((function(_this) {
          return function(connector) {
            return connector.name === name;
          };
        })(this));
      };

      NodeModel.prototype.set_graph = function(graph) {
        this.graph = graph;
      };

      NodeModel.prototype.set_bounds = function(bounds) {
        this.bounds = bounds;
      };

      NodeModel.prototype.add = function() {
        var connector, connectors, _i, _len;
        connectors = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        for (_i = 0, _len = connectors.length; _i < _len; _i++) {
          connector = connectors[_i];
          if (isinstance(connector, models.ConnectorModel)) {
            connector.set_node(this);
            this.connectors.push(connector);
          } else {
            throw "Invalid type";
          }
        }
        return this;
      };

      NodeModel.prototype.highlight = function(type) {
        return this.trigger("highlight", type);
      };

      NodeModel.prototype.select = function() {
        return this.trigger("select", this);
      };

      NodeModel.prototype.deselect = function() {
        return this.trigger("deselect", this);
      };

      NodeModel.prototype.moveBy = function(dx, dy) {
        return this.set({
          x: this.attributes.x + dx,
          y: this.attributes.y + dy
        });
      };

      NodeModel.prototype.destroy = function() {
        this.trigger('destroy', this, this.collection);
        this.connectors.destroy();
        delete this.graph;
        return delete this.bounds;
      };

      return NodeModel;

    })(Backbone.Model);
    models.ConnectorModel = (function(_super) {
      __extends(ConnectorModel, _super);

      function ConnectorModel() {
        return ConnectorModel.__super__.constructor.apply(this, arguments);
      }

      ConnectorModel.prototype.defaults = {
        name: "",
        title: ""
      };

      ConnectorModel.property("key", {
        get: function() {
          return this.node.id + "|" + this.get("name");
        }
      });

      ConnectorModel.prototype.set_node = function(node) {
        this.node = node;
        this.node.on("selected", this._on_select, this);
        return this.node.on("deselected", this._on_deselect, this);
      };

      ConnectorModel.prototype._on_select = function() {
        return this.trigger("select");
      };

      ConnectorModel.prototype._on_deselect = function() {
        return this.trigger("deselect");
      };

      ConnectorModel.prototype.set_position = function(pos) {
        this.pos = pos;
      };

      ConnectorModel.prototype.destroy = function() {
        this.trigger('destroy', this, this.collection);
        delete this.node;
        return delete this.pos;
      };

      return ConnectorModel;

    })(Backbone.Model);
    models.InputConnectorModel = (function(_super) {
      __extends(InputConnectorModel, _super);

      function InputConnectorModel() {
        return InputConnectorModel.__super__.constructor.apply(this, arguments);
      }

      return InputConnectorModel;

    })(models.ConnectorModel);
    models.OutputConnectorModel = (function(_super) {
      __extends(OutputConnectorModel, _super);

      function OutputConnectorModel() {
        return OutputConnectorModel.__super__.constructor.apply(this, arguments);
      }

      return OutputConnectorModel;

    })(models.ConnectorModel);
    return models.ConnectionModel = (function(_super) {
      __extends(ConnectionModel, _super);

      ConnectionModel.prototype["default"] = {
        start: null,
        end: null
      };

      function ConnectionModel(options) {
        var end, start;
        ConnectionModel.__super__.constructor.call(this, options);
        start = this.get("start");
        end = this.get("end");
        start.on("destroy", this.destroy, this);
        end.on("destroy", this.destroy, this);
      }

      return ConnectionModel;

    })(Backbone.Model);
  });

  define("revigred.collections", ['Backbone.Collection', 'revigred.models.NodeModel'], function() {
    var collections, models;
    models = namespace("revigred.models");
    collections = namespace("revigred.collections");
    this.NodesList = (function(_super) {
      __extends(NodesList, _super);

      NodesList.prototype.model = models.NodeModel;

      function NodesList(options) {
        var _ref;
        NodesList.__super__.constructor.call(this, options);
        this.selection = new collections.Selection();
        if ((_ref = this.selection) != null) {
          _ref.on("remove", this._on_restore, this);
        }
      }

      NodesList.prototype._on_restore = function(node, collection) {
        return this.trigger("restore", node);
      };

      NodesList.prototype.set_dragging_callback = function(callback) {
        var _ref;
        return (_ref = this.selection) != null ? _ref.set_dragging_callback(callback) : void 0;
      };

      NodesList.prototype.drag = function(dx, dy) {
        var _ref;
        this.toArray().forEach(function(node) {
          node.moveBy(dx, dy);
          return false;
        });
        return (_ref = this.selection) != null ? _ref.notify_dragging() : void 0;
      };

      return NodesList;

    })(Backbone.Collection);
    this.ConnectorsList = (function(_super) {
      __extends(ConnectorsList, _super);

      function ConnectorsList() {
        return ConnectorsList.__super__.constructor.apply(this, arguments);
      }

      ConnectorsList.prototype.destroy = function() {
        this.toArray().forEach(function(conn) {
          return conn.destroy();
        });
        return this.trigger('destroy', this, this.collection);
      };

      return ConnectorsList;

    })(Backbone.Collection);
    this.Selection = (function(_super) {
      __extends(Selection, _super);

      Selection.prototype.model = models.NodeModel;

      function Selection(options) {
        Selection.__super__.constructor.call(this, options);
      }

      Selection.prototype.add = function(node) {
        Selection.__super__.add.call(this, node);
        return node.set("selected", true);
      };

      Selection.prototype.remove = function(node) {
        Selection.__super__.remove.call(this, node);
        return node.set("selected", false);
      };

      Selection.prototype.deselect_all = function() {
        return _.forEach(this.toArray(), (function(_this) {
          return function(node) {
            return _this.remove(node);
          };
        })(this));
      };

      Selection.prototype.set_dragging_callback = function(callback) {
        return this.dragging_callback = callback;
      };

      Selection.prototype.notify_dragging = function() {
        if (this.dragging_callback != null) {
          this.dragging_callback();
          return delete this.dragging_callback;
        }
      };

      Selection.prototype.drag = function(dx, dy) {
        this.toArray().forEach(function(node) {
          node.moveBy(dx, dy);
          return false;
        });
        return this.notify_dragging();
      };

      Selection.prototype.delete_selected = function() {
        return this.toArray().forEach(function(node) {
          node.deselect();
          return node.destroy();
        });
      };

      return Selection;

    })(Backbone.Collection);
    return this.ConnectionsList = (function(_super) {
      __extends(ConnectionsList, _super);

      function ConnectionsList() {
        return ConnectionsList.__super__.constructor.apply(this, arguments);
      }

      models.ConnectionModel;

      return ConnectionsList;

    })(Backbone.Collection);
  });

  define([], function() {
    var root;
    root = this;
    return root.QuadKey = (function() {
      function QuadKey(code) {
        this.code = code;
        if (this.code == null) {
          this.code = "";
        }
      }

      QuadKey.prototype.decode = function(code) {
        var char, seq, _i, _len;
        seq = [];
        for (_i = 0, _len = code.length; _i < _len; _i++) {
          char = code[_i];
          switch (char) {
            case "@":
              seq.push(0);
              break;
            case "D":
              seq.push(0, 0);
              break;
            case "E":
              seq.push(0, 1);
              break;
            case "F":
              seq.push(0, 2);
              break;
            case "G":
              seq.push(0, 3);
              break;
            case "H":
              seq.push(1);
              break;
            case "L":
              seq.push(1, 0);
              break;
            case "M":
              seq.push(1, 1);
              break;
            case "N":
              seq.push(1, 2);
              break;
            case "O":
              seq.push(1, 3);
              break;
            case "P":
              seq.push(2);
              break;
            case "T":
              seq.push(2, 0);
              break;
            case "U":
              seq.push(2, 1);
              break;
            case "V":
              seq.push(2, 2);
              break;
            case "W":
              seq.push(2, 3);
              break;
            case "X":
              seq.push(3);
              break;
            case "\\":
              seq.push(3, 0);
              break;
            case "]":
              seq.push(3, 1);
              break;
            case "^":
              seq.push(3, 2);
              break;
            case "_":
              seq.push(3, 3);
          }
        }
        return seq;
      };

      QuadKey.prototype.encode = function(seq) {
        var first, index, len, result, second;
        result = "";
        len = seq.length;
        index = 0;
        while (true) {
          if (index >= len) {
            break;
          }
          first = seq[index++];
          if (index >= len) {
            switch (first) {
              case 0:
                result += "@";
                break;
              case 1:
                result += "H";
                break;
              case 2:
                result += "P";
                break;
              case 3:
                result += "X";
            }
          } else {
            second = seq[index++];
            switch (first) {
              case 0:
                switch (second) {
                  case 0:
                    result += "D";
                    break;
                  case 1:
                    result += "E";
                    break;
                  case 2:
                    result += "F";
                    break;
                  case 3:
                    result += "G";
                }
                break;
              case 1:
                switch (second) {
                  case 0:
                    result += "L";
                    break;
                  case 1:
                    result += "M";
                    break;
                  case 2:
                    result += "N";
                    break;
                  case 3:
                    result += "O";
                }
                break;
              case 2:
                switch (second) {
                  case 0:
                    result += "T";
                    break;
                  case 1:
                    result += "U";
                    break;
                  case 2:
                    result += "V";
                    break;
                  case 3:
                    result += "W";
                }
                break;
              case 3:
                switch (second) {
                  case 0:
                    result += "\\";
                    break;
                  case 1:
                    result += "]";
                    break;
                  case 2:
                    result += "^";
                    break;
                  case 3:
                    result += "_";
                }
            }
          }
        }
        return result;
      };

      QuadKey.prototype.tl = function() {
        var seq;
        seq = this.decode(this.code);
        seq.push(0);
        return new this.constructor(this.encode(seq));
      };

      QuadKey.prototype.tr = function() {
        var seq;
        seq = this.decode(this.code);
        seq.push(1);
        return new this.constructor(this.encode(seq));
      };

      QuadKey.prototype.bl = function() {
        var seq;
        seq = this.decode(this.code);
        seq.push(3);
        return new this.constructor(this.encode(seq));
      };

      QuadKey.prototype.br = function() {
        var seq;
        seq = this.decode(this.code);
        seq.push(2);
        return new this.constructor(this.encode(seq));
      };

      return QuadKey;

    })();
  });

  math = Math;

  $.widget("ui.selector", $.ui.mouse, {
    options: {
      distance: 0,
      tolerance: 'touch'
    },
    _create: function() {
      this._mouseInit();
      this.tooltip = $("<div class='ui-tooltip ui-widget ui-widget-content'></div>");
      this.helper = $("<div class='ui-selectable-helper'></div>");
      this.helper.append(this.tooltip);
      this.anchorX = false;
      return this.anchorY = false;
    },
    _destroy: function() {
      return this._mouseDestroy();
    },
    _mouseStart: function(event) {
      if (this.options.disabled) {
        return false;
      }
      this.offset = this.element.offset();
      this.x = event.pageX - this.offset.left;
      this.y = event.pageY - this.offset.top;
      this.shiftKey = event.shiftKey;
      this.altKey = event.altKey;
      this.ctrlKey = event.ctrlKey;
      this.rect = new math.Rect(this.x, this.y, this.x, this.y);
      if (!this._trigger("start", event, this)) {
        return false;
      }
      $(this.element).append(this.helper);
      this.helper.css({
        left: this.x,
        top: this.y,
        width: 0,
        height: 0
      });
      $(window).on('keydown.' + this.widgetName, (function(_this) {
        return function(event) {
          switch (event.keyCode) {
            case 16:
              _this._setShift(true);
              break;
            case 17:
              _this._setCtrl(true);
              break;
            case 18:
              _this._setAlt(true);
              break;
            default:
              return true;
          }
          event.preventDefault();
          return false;
        };
      })(this));
      return $(window).on('keyup.' + this.widgetName, (function(_this) {
        return function(event) {
          switch (event.keyCode) {
            case 16:
              _this._setShift(false);
              break;
            case 17:
              _this._setCtrl(false);
              break;
            case 18:
              _this._setAlt(false);
              break;
            default:
              return true;
          }
          event.preventDefault();
          return false;
        };
      })(this));
    },
    say: function(text) {
      return this.tooltip.text(text);
    },
    _setAlt: function(state) {
      if (this.altKey !== state) {
        this.altKey = state;
        return this._trigger("switch", event, this);
      }
    },
    _setShift: function(state) {
      if (this.shiftKey !== state) {
        this.shiftKey = state;
        return this._trigger("switch", event, this);
      }
    },
    _setCtrl: function(state) {
      if (this.ctrlKey !== state) {
        this.ctrlKey = state;
        return this._trigger("switch", event, this);
      }
    },
    _mouseDrag: function(event) {
      var anchorX, anchorY, rect, x, y;
      x = event.pageX - this.offset.left;
      y = event.pageY - this.offset.top;
      anchorX = x > this.x;
      anchorY = y > this.y;
      if (anchorX !== this.anchorX) {
        this.anchorX = anchorX;
        if (anchorX) {
          this.tooltip.css({
            left: "auto",
            right: 0
          });
        } else {
          this.tooltip.css({
            left: 0,
            right: "auto"
          });
        }
      }
      if (anchorY !== this.anchorY) {
        this.anchorY = anchorY;
        if (anchorY) {
          this.tooltip.css({
            top: "auto",
            bottom: 0
          });
        } else {
          this.tooltip.css({
            top: 0,
            bottom: "auto"
          });
        }
      }
      this.rect = rect = new math.Rect(this.x, this.y, x, y);
      this.helper.css({
        left: rect.min_x,
        top: rect.min_y,
        width: rect.width,
        height: rect.height
      });
      this._trigger("update", event, this);
      return false;
    },
    _mouseStop: function(event) {
      $(window).off('keydown.' + this.widgetName);
      $(window).off('keyup.' + this.widgetName);
      this._trigger("stop", event, this);
      this.helper.remove();
      return false;
    },
    _mouseCapture: function(event) {
      return true;
    }
  });

  define("revigred.settings", [], function() {
    this.is_select = function(event) {
      if (event.which !== 1) {
        return false;
      }
      if (event.shiftKey) {
        return false;
      }
      if (event.ctrlKey) {
        return false;
      }
      if (event.altKey) {
        return false;
      }
      return true;
    };
    this.is_join_select = function(event) {
      if (event.which !== 1) {
        return false;
      }
      if (event.shiftKey) {
        return false;
      }
      if (!event.ctrlKey) {
        return false;
      }
      if (event.altKey) {
        return false;
      }
      return true;
    };
    this.get_selection_rule = function(ctrl, shift, alt) {
      if (ctrl && !shift && !alt) {
        return UnionDiff;
      }
      if (!ctrl && shift && !alt) {
        return IntersectDiff;
      }
      if (!ctrl && !shift && alt) {
        return DifferenceDiff;
      }
      if (!ctrl && !shift && !alt) {
        return ReplaceDiff;
      }
      return null;
    };
    return null;
  });

  define([], function() {
    var root, _base, _isinstance;
    root = this;
    if ((_base = Function.prototype).property == null) {
      _base.property = function(prop, desc) {
        return Object.defineProperty(this.prototype, prop, desc);
      };
    }
    _isinstance = function() {
      var t, type, types, _i, _len;
      t = arguments[0], types = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      for (_i = 0, _len = types.length; _i < _len; _i++) {
        type = types[_i];
        if (type === t) {
          return true;
        }
      }
      if (t.__proto__ != null) {
        return _isinstance.apply(null, [t.__proto__].concat(__slice.call(types)));
      }
      return false;
    };
    root.isinstance = function() {
      var type, types, value;
      value = arguments[0], types = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      types = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = types.length; _i < _len; _i++) {
          type = types[_i];
          _results.push(type.prototype);
        }
        return _results;
      })();
      return _isinstance.apply(null, [value].concat(__slice.call(types)));
    };
    root.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
      return window.setTimeout(callback, 20);
    };
    root.Diff = (function() {
      function Diff(old, _new) {
        this.old = old != null ? old : [];
        this["new"] = _new;
        if (this["new"] == null) {
          this["new"] = this.old;
        }
      }

      Diff.property('removed', {
        get: function() {
          return this._removed != null ? this._removed : this._removed = _.difference(this.old, this["new"]);
        }
      });

      Diff.property('unchanged', {
        get: function() {
          return this._unchanged != null ? this._unchanged : this._unchanged = _.intersection(this.old, this["new"]);
        }
      });

      Diff.property('added', {
        get: function() {
          return this._added != null ? this._added : this._added = _.difference(this["new"], this.old);
        }
      });

      Diff.prototype.clear = function() {
        delete this._removed;
        delete this._unchanged;
        return delete this._added;
      };

      Diff.prototype.update = function(current) {
        this.old = this["new"];
        this["new"] = current;
        return this.clear();
      };

      return Diff;

    })();
    root.DiffWithBase = (function() {
      function DiffWithBase() {}

      DiffWithBase.prototype.clear = function() {
        delete this._remain;
        delete this._unset;
        delete this._common;
        delete this._added;
        delete this._removed;
        return delete this._result;
      };

      DiffWithBase.prototype.update = function(current) {
        this.current = current != null ? current : [];
        this.diff.update(this.current);
        return this.clear();
      };

      return DiffWithBase;

    })();
    root.UnionDiff = (function(_super) {
      __extends(UnionDiff, _super);

      UnionDiff.prototype.name = "Union";

      function UnionDiff(base) {
        this.base = base;
        this.diff = new root.Diff();
      }

      UnionDiff.property('remain', {
        get: function() {
          return this._remain != null ? this._remain : this._remain = _.intersection(this.diff.removed, this.base);
        }
      });

      UnionDiff.property('unset', {
        get: function() {
          return this._unset != null ? this._unset : this._unset = _.difference(this.diff.removed, this.base);
        }
      });

      UnionDiff.property('common', {
        get: function() {
          return this._common != null ? this._common : this._common = _.intersection(this.diff.added, this.base);
        }
      });

      UnionDiff.property('added', {
        get: function() {
          return this._added != null ? this._added : this._added = _.difference(this.diff.added, this.base);
        }
      });

      UnionDiff.property('removed', {
        get: function() {
          return this._removed != null ? this._removed : this._removed = [];
        }
      });

      UnionDiff.property('result', {
        get: function() {
          return this._result != null ? this._result : this._result = new root.Diff(this.base, _.union(this.base, this.current));
        }
      });

      return UnionDiff;

    })(root.DiffWithBase);
    root.ReplaceDiff = (function(_super) {
      __extends(ReplaceDiff, _super);

      ReplaceDiff.prototype.name = "Replace";

      function ReplaceDiff(base) {
        this.base = base;
        this.diff = new root.Diff(this.base);
      }

      ReplaceDiff.property('remain', {
        get: function() {
          return this._remain != null ? this._remain : this._remain = [];
        }
      });

      ReplaceDiff.property('unset', {
        get: function() {
          return this._unset != null ? this._unset : this._unset = _.difference(this.diff.removed, this.base);
        }
      });

      ReplaceDiff.property('common', {
        get: function() {
          return this._common != null ? this._common : this._common = _.intersection(this.diff.added, this.base);
        }
      });

      ReplaceDiff.property('added', {
        get: function() {
          return this._added != null ? this._added : this._added = _.difference(this.diff.added, this.base);
        }
      });

      ReplaceDiff.property('removed', {
        get: function() {
          return this._removed != null ? this._removed : this._removed = _.intersection(this.base, this.diff.removed);
        }
      });

      ReplaceDiff.property('result', {
        get: function() {
          return this._result != null ? this._result : this._result = new root.Diff(this.base, this.current);
        }
      });

      return ReplaceDiff;

    })(root.DiffWithBase);
    root.IntersectDiff = (function(_super) {
      __extends(IntersectDiff, _super);

      IntersectDiff.prototype.name = "Intersect";

      function IntersectDiff(base) {
        this.base = base;
        this.diff = new root.Diff(this.base);
      }

      IntersectDiff.property('remain', {
        get: function() {
          return this._remain != null ? this._remain : this._remain = [];
        }
      });

      IntersectDiff.property('unset', {
        get: function() {
          return this._unset != null ? this._unset : this._unset = _.difference(this.diff.removed, this.base);
        }
      });

      IntersectDiff.property('common', {
        get: function() {
          return this._common != null ? this._common : this._common = _.intersection(this.diff.added, this.base);
        }
      });

      IntersectDiff.property('added', {
        get: function() {
          return this._added != null ? this._added : this._added = [];
        }
      });

      IntersectDiff.property('removed', {
        get: function() {
          return this._removed != null ? this._removed : this._removed = _.intersection(this.base, this.diff.removed);
        }
      });

      IntersectDiff.property('result', {
        get: function() {
          return this._result != null ? this._result : this._result = new root.Diff(this.base, _.intersection(this.base, this.current));
        }
      });

      return IntersectDiff;

    })(root.DiffWithBase);
    return root.DifferenceDiff = (function(_super) {
      __extends(DifferenceDiff, _super);

      DifferenceDiff.prototype.name = "Difference";

      function DifferenceDiff(base) {
        this.base = base;
        this.diff = new root.Diff();
      }

      DifferenceDiff.property('remain', {
        get: function() {
          return this._remain != null ? this._remain : this._remain = _.intersection(this.base, this.diff.removed);
        }
      });

      DifferenceDiff.property('unset', {
        get: function() {
          return this._unset != null ? this._unset : this._unset = [];
        }
      });

      DifferenceDiff.property('common', {
        get: function() {
          return this._common != null ? this._common : this._common = [];
        }
      });

      DifferenceDiff.property('added', {
        get: function() {
          return this._added != null ? this._added : this._added = [];
        }
      });

      DifferenceDiff.property('removed', {
        get: function() {
          return this._removed != null ? this._removed : this._removed = _.intersection(this.base, this.diff.added);
        }
      });

      DifferenceDiff.property('result', {
        get: function() {
          return this._result != null ? this._result : this._result = new root.Diff(this.base, _.difference(this.base, this.current));
        }
      });

      return DifferenceDiff;

    })(root.DiffWithBase);
  });

  define(["Backbone.View"], function() {
    var controller, gizmos, models, settings, views;
    views = namespace("revigred.views");
    math = namespace("Math");
    settings = namespace("revigred.settings");
    gizmos = namespace("revigred.gizmos");
    controller = namespace("revigred.controller");
    models = namespace("revigred.models");
    views.GraphView = (function(_super) {
      __extends(GraphView, _super);

      GraphView.prototype._dragging = false;

      function GraphView(options) {
        GraphView.__super__.constructor.call(this, options);
        this.controller = new controller.Controller({
          graph: this
        });
        this.nodes = new views.NodesView({
          model: this.model.nodes,
          controller: this.controller
        });
        this.connections = new views.ConnectionsView({
          model: this.model.connections,
          controller: this.controller
        });
        this._benchmark_time = 0;
        this._benchmark_count = 0;
      }

      GraphView.prototype.render = function(callback) {
        var $window;
        $window = $(window).on('keydown.revigred', (function(_this) {
          return function(event) {
            return _this.$el.focus();
          };
        })(this)).on('keyup.revigred', (function(_this) {
          return function(event) {
            return _this._on_keyup(event);
          };
        })(this));
        this.$nodes = this.nodes.render().$el;
        this.$el.append(this.$nodes).disableSelection();
        $(window).resize((function(_this) {
          return function() {
            return _this.resize();
          };
        })(this));
        this.resize();
        return this._draw_wrapper(callback);
      };

      GraphView.prototype.resize = function() {};

      GraphView.prototype._draw_wrapper = function(callback) {
        var start;
        start = Date.now();
        this.draw(callback);
        requestAnimationFrame((function(_this) {
          return function() {
            return _this._draw_wrapper(callback);
          };
        })(this));
        this._benchmark_time += Date.now() - start;
        if (this._benchmark_count >= 200) {
          console.log(("canvas draw: " + (this._benchmark_time / this._benchmark_count) + " ms, nodes: " + this.model.nodes.length + " connections: " + this.model.connections.length).trim());
          this._benchmark_time = 0;
          return this._benchmark_count = 0;
        }
      };

      GraphView.prototype.draw = function(callback) {
        return typeof callback === "function" ? callback() : void 0;
      };

      GraphView.prototype._on_keyup = function(event) {
        switch (event.which) {
          case 46:
            return this.model.nodes.selection.delete_selected();
          case 27:
            return this.model.nodes.selection.deselect_all();
        }
      };

      return GraphView;

    })(Backbone.View);
    views.GraphCanvasView = (function(_super) {
      __extends(GraphCanvasView, _super);

      function GraphCanvasView() {
        return GraphCanvasView.__super__.constructor.apply(this, arguments);
      }

      GraphCanvasView.prototype.events = {
        "mousemove": "_on_mousemove",
        "mouseup": "_on_mouseup"
      };

      GraphCanvasView.prototype.render = function(callback) {
        this.canvas = document.createElement("canvas");
        this.$el.append(this.canvas);
        this.$canvas = $(this.canvas);
        this.context = this.canvas.getContext("2d");
        return GraphCanvasView.__super__.render.call(this, callback);
      };

      GraphCanvasView.prototype.resize = function() {
        this.canvas.width = this.$el.innerWidth();
        this.canvas.height = this.$el.innerHeight();
        this._offset = this.$canvas.offset();
        return this.context.translate(-this._offset.left, -this._offset.top);
      };

      GraphCanvasView.prototype._on_mousemove = function(event) {
        return this.cursor = new math.Vector(event.pageX, event.pageY);
      };

      GraphCanvasView.prototype._on_mouseup = function(event) {
        return this.model.drop_start();
      };

      GraphCanvasView.prototype.draw = function(callback) {
        var ctx, dir, pos;
        GraphCanvasView.__super__.draw.call(this, callback);
        this.context.clearRect(this._offset.left, this._offset.top, this.$el.innerWidth(), this.$el.innerHeight());
        this.connections.render_canvas(this.context);
        if (this.model.start_connector != null) {
          ctx = this.context;
          pos = this.model.start_connector.pos().v1;
          dir = new Math.Vector(pos.x - this.cursor.x, pos.y - this.cursor.y).normalize();
          ctx.beginPath();
          gizmos.EdgeGizmo.drawDir(ctx, this.model.start_connector, this.cursor);
          ctx.stroke();
          ctx.closePath();
          ctx.strokeStyle = "rgb(0,0,0)";
          ctx.beginPath();
          ctx.moveTo(this.cursor.x, this.cursor.y);
          ctx.lineTo(this.cursor.x + dir.x * 10 - dir.y * 6, this.cursor.y + dir.y * 10 + dir.x * 6);
          ctx.lineTo(this.cursor.x + dir.x * 10 + dir.y * 6, this.cursor.y + dir.y * 10 - dir.x * 6);
          ctx.lineTo(this.cursor.x, this.cursor.y);
          ctx.fill();
          ctx.closePath();
        }
        return this.model.nodes.forEach((function(_this) {
          return function(node) {
            var view;
            view = _this.controller.get_node_view(node);
            view.draw(_this);
            return null;
          };
        })(this));
      };

      return GraphCanvasView;

    })(views.GraphView);
    views.NodesView = (function(_super) {
      __extends(NodesView, _super);

      NodesView.prototype.tagName = 'div';

      NodesView.prototype.className = 'nodes';

      function NodesView(options) {
        NodesView.__super__.constructor.call(this, options);
        this.controller = options.controller;
        if (this.model.selection != null) {
          this.selection = new views.SelectionView({
            model: this.model.selection,
            controller: this.controller
          });
        }
        this.model.on('add', this._add, this);
        this.model.on('reset', this._reset, this);
        this.model.on('restore', this._restore, this);
      }

      NodesView.prototype._reset = function() {
        return this.model.forEach(this._add, this);
      };

      NodesView.prototype._add = function(node) {
        var view;
        view = this.controller.get_node_view(node);
        this.$el.append(view.render().el);
        return null;
      };

      NodesView.prototype._restore = function(node) {
        var view;
        view = this.controller.get_node_view(node);
        this.$el.append(view.el);
        return view.restore();
      };

      NodesView.prototype._highlight = function() {
        this._diff.unset.forEach(function(node) {
          return node.highlight(null);
        });
        this._diff.remain.forEach(function(node) {
          return node.highlight("selected");
        });
        this._diff.common.forEach(function(node) {
          return node.highlight("intersect");
        });
        this._diff.added.forEach(function(node) {
          return node.highlight("added");
        });
        return this._diff.removed.forEach(function(node) {
          return node.highlight("removed");
        });
      };

      NodesView.prototype._cancel_highlight = function() {
        this._diff.result.added.forEach(function(node) {
          return node.highlight(null);
        });
        this._diff.result.unchanged.forEach(function(node) {
          return node.highlight("selected");
        });
        return this._diff.result.removed.forEach(function(node) {
          return node.highlight("selected");
        });
      };

      NodesView.prototype.render = function() {
        if (this.selection != null) {
          this.$el.append(this.selection.render().el).selector({
            distance: 3,
            start: (function(_this) {
              return function(event, widget) {
                var new_rule;
                new_rule = settings.get_selection_rule(widget.ctrlKey, widget.shiftKey, widget.altKey);
                _this._diff = new new_rule(_this.model.selection.models);
                return widget.say(_this._diff.name);
              };
            })(this),
            update: (function(_this) {
              return function(event, widget) {
                var _selected;
                _selected = _this.model.filter(function(node) {
                  return widget.rect.intersect(node.bounds());
                });
                _this._diff.update(_selected);
                return _this._highlight();
              };
            })(this),
            "switch": (function(_this) {
              return function(event, widget) {
                var current, new_rule;
                new_rule = settings.get_selection_rule(widget.ctrlKey, widget.shiftKey, widget.altKey);
                if (new_rule != null) {
                  current = _this._diff.current;
                  _this._cancel_highlight();
                  _this._diff = new new_rule(_this.model.selection.models);
                  _this._diff.update();
                  _this._highlight();
                  _this._diff.update(current);
                  _this._highlight();
                  return widget.say(_this._diff.name);
                }
              };
            })(this),
            stop: (function(_this) {
              return function(event, widget) {
                _this._diff.result.added.forEach(function(node) {
                  return node.select();
                });
                _this._diff.result.unchanged.forEach(function(node) {
                  return node.highlight("selected");
                });
                _this._diff.result.removed.forEach(function(node) {
                  return node.deselect();
                });
                return delete _this._diff;
              };
            })(this)
          });
        }
        this.$el.draggable({
          scroll: false,
          distance: 3,
          which: 3,
          stop: (function(_this) {
            return function(event, ui) {
              _this.model.drag(_this.el.offsetLeft, _this.el.offsetTop);
              return _this.$el.css({
                left: 0,
                top: 0
              });
            };
          })(this)
        }).css({
          position: "absolute"
        });
        this._reset();
        return this;
      };

      return NodesView;

    })(Backbone.View);
    views.SelectionView = (function(_super) {
      __extends(SelectionView, _super);

      SelectionView.prototype.tagName = 'div';

      SelectionView.prototype.className = 'selection';

      SelectionView.prototype.events = {
        "click": "_on_click",
        "mousedown": "_on_mousedown"
      };

      function SelectionView(options) {
        SelectionView.__super__.constructor.call(this, options);
        this.controller = options.controller;
        this.model.on('add', this._add, this);
        this.model.on('remove', this._remove, this);
        this.counter = 0;
        this.dragged = false;
      }

      SelectionView.prototype._add = function(node) {
        var view;
        view = this.controller.get_node_view(node);
        this.counter++;
        return this.$el.show().append(view.$el.css("z-index", this.counter));
      };

      SelectionView.prototype._remove = function(node) {
        if (this.model.length === 0) {
          return this.$el.hide();
        }
      };

      SelectionView.prototype.render = function() {
        this.$el.draggable({
          handle: ".node",
          scroll: false,
          distance: 3,
          stop: (function(_this) {
            return function(event, ui) {
              _this.dragged = true;
              _this.model.drag(_this.el.offsetLeft, _this.el.offsetTop);
              return _this.$el.css({
                left: 0,
                top: 0
              });
            };
          })(this)
        }).css({
          position: "absolute"
        }).hide();
        return this;
      };

      SelectionView.prototype._on_mousedown = function(event) {
        this.dragged = false;
        return true;
      };

      SelectionView.prototype._on_click = function(event) {
        if (this.dragged) {
          this.dragged = false;
          event.stopPropagation();
        } else {
          if (settings.is_select(event)) {
            this.model.deselect_all();
          }
        }
        return false;
      };

      return SelectionView;

    })(Backbone.View);
    views.NodeView = (function(_super) {
      __extends(NodeView, _super);

      NodeView.prototype.tagName = 'div';

      NodeView.prototype.className = 'node ui-widget ui-widget-content ui-corner-all';

      function NodeView(options) {
        NodeView.__super__.constructor.call(this, options);
        this.left = new views.LeftConnectorsView({
          model: this.model.connectors
        });
        this.right = new views.RightConnectorsView({
          model: this.model.connectors
        });
        this.model.set_bounds((function(_this) {
          return function() {
            return _this.bounds();
          };
        })(this));
        this.model.on('highlight', this._apply_highlight, this);
        this.model.on('change:x', this._x_changed, this);
        this.model.on('change:y', this._y_changed, this);
        this.model.on('change:title', this._title_changed, this);
        this.model.on('change:selected', this._selected_changed, this);
        this.model.on('change:local', this._local_changed, this);
        this.model.on("remove", this.remove, this);
        this.dragged = false;
      }

      NodeView.prototype.events = {
        "click": "_on_click",
        "mousedown": "_on_mousedown",
        "mouseenter": "_on_mouse_enter",
        "mouseleave": "_on_mouse_leave"
      };

      NodeView.prototype._on_click = function(event) {
        if (this.dragged) {
          this.dragged = false;
          event.stopPropagation();
        } else {
          if (settings.is_select(event)) {
            this.model.graph.deselect_all();
            this.model.select();
          }
          if (settings.is_join_select(event)) {
            if (this.model.get("selected")) {
              this.model.deselect();
            } else {
              this.model.select();
            }
          }
        }
        return false;
      };

      NodeView.prototype._on_mouse_enter = function(event) {
        return this.$el.addClass("ui-state-hover");
      };

      NodeView.prototype._on_mouse_leave = function(event) {
        return this.$el.removeClass("ui-state-hover");
      };

      NodeView.prototype._on_dragged = function() {
        return this.dragged = true;
      };

      NodeView.prototype._on_mousedown = function(event) {
        this.dragged = false;
        return this.model.graph.nodes.set_dragging_callback((function(_this) {
          return function() {
            return _this._on_dragged();
          };
        })(this));
      };

      NodeView.prototype._local_changed = function(node, value) {
        if (value) {
          return this.$el.addClass("local-node");
        } else {
          return this.$el.removeClass("local-node");
        }
      };

      NodeView.prototype._x_changed = function(node, value) {
        return this.$el.css({
          left: value
        });
      };

      NodeView.prototype._y_changed = function(node, value) {
        return this.$el.css({
          top: value
        });
      };

      NodeView.prototype._title_changed = function(node, value) {
        return this.$header.text(value);
      };

      NodeView.prototype._apply_highlight = function(highlight) {
        if (this.highlight !== highlight) {
          if (this.highlight != null) {
            this.$el.removeClass("node-highlight-" + this.highlight);
          }
          this.highlight = highlight;
          if (this.highlight != null) {
            return this.$el.addClass("node-highlight-" + this.highlight);
          }
        }
      };

      NodeView.prototype._selected_changed = function(node, value) {
        if (value) {
          return this._apply_highlight("selected");
        } else {
          return this._apply_highlight(null);
        }
      };

      NodeView.prototype.restore = function() {
        this.delegateEvents();
        this.left.restore();
        return this.right.restore();
      };

      NodeView.prototype.draw = function(graph) {
        this.left.draw(graph);
        return this.right.draw(graph);
      };

      NodeView.prototype.render = function() {
        this.$header = $("<div>").addClass("ui-widget-header ui-corner-top").text(this.model.get("title"));
        this.$el.css({
          left: this.model.get("x"),
          top: this.model.get("y")
        }).attr("id", this.model.id).append(this.$header).append(this.left.render().el).append(this.right.render().el).disableSelection();
        this._local_changed(this.model, this.model.get("local"));
        return this;
      };

      NodeView.prototype.bounds = function() {
        var height, left, pos, top, width;
        pos = this.$el.offset();
        left = pos.left;
        top = pos.top;
        width = this.$el.outerWidth();
        height = this.$el.outerHeight();
        return new math.Rect(left, top, left + width, top + height);
      };

      return NodeView;

    })(Backbone.View);
    views.ConnectorsView = (function(_super) {
      __extends(ConnectorsView, _super);

      ConnectorsView.prototype.tagName = 'ui';

      function ConnectorsView(options) {
        ConnectorsView.__super__.constructor.call(this, options);
        this.connectors = [];
        this.model.on('add', this.addOne, this);
        this.model.on('reset', this.addAll, this);
      }

      ConnectorsView.prototype.addAll = function() {
        return this.model.forEach(this.addOne, this);
      };

      ConnectorsView.prototype.addOne = function(connector) {
        var removeOne, view;
        view = this.make_connector({
          model: connector
        });
        this.connectors.push(view);
        this.$el.append(view.render().el);
        removeOne = function(item, collection) {
          var index;
          if (collection !== this.model) {
            return;
          }
          index = this.connectors.indexOf(view);
          if (index >= 0) {
            this.connectors.splice(index, 1);
          }
          return item.off("remove", null, this);
        };
        connector.on("remove", removeOne, this);
        return null;
      };

      ConnectorsView.prototype.restore = function() {
        this.delegateEvents();
        return this.connectors.forEach(function(conn) {
          return conn.restore();
        });
      };

      ConnectorsView.prototype.render = function() {
        this.addAll();
        return this;
      };

      ConnectorsView.prototype.draw = function(graph) {
        return this.connectors.forEach(function(conn) {
          if (typeof conn.draw === "function") {
            conn.draw(graph);
          }
          return null;
        });
      };

      return ConnectorsView;

    })(Backbone.View);
    views.LeftConnectorsView = (function(_super) {
      __extends(LeftConnectorsView, _super);

      function LeftConnectorsView() {
        return LeftConnectorsView.__super__.constructor.apply(this, arguments);
      }

      LeftConnectorsView.prototype.className = 'left-connectors';

      LeftConnectorsView.prototype.make_connector = function(options) {
        return new views.LeftConnectorView(options);
      };

      LeftConnectorsView.prototype.addOne = function(connector) {
        if (!isinstance(connector, models.InputConnectorModel)) {
          return;
        }
        return LeftConnectorsView.__super__.addOne.call(this, connector);
      };

      return LeftConnectorsView;

    })(views.ConnectorsView);
    views.RightConnectorsView = (function(_super) {
      __extends(RightConnectorsView, _super);

      function RightConnectorsView() {
        return RightConnectorsView.__super__.constructor.apply(this, arguments);
      }

      RightConnectorsView.prototype.className = 'right-connectors';

      RightConnectorsView.prototype.render = function() {
        RightConnectorsView.__super__.render.call(this);
        this.$el.attr("dir", "rtl");
        return this;
      };

      RightConnectorsView.prototype.make_connector = function(options) {
        return new views.RightConnectorView(options);
      };

      RightConnectorsView.prototype.addOne = function(connector) {
        if (!isinstance(connector, models.OutputConnectorModel)) {
          return;
        }
        return RightConnectorsView.__super__.addOne.call(this, connector);
      };

      return RightConnectorsView;

    })(views.ConnectorsView);
    views.ConnectorView = (function(_super) {
      __extends(ConnectorView, _super);

      ConnectorView.prototype.tagName = 'li';

      ConnectorView.prototype.className = 'connector ui-state-default';

      function ConnectorView(options) {
        ConnectorView.__super__.constructor.call(this, options);
        this.model.set_position((function(_this) {
          return function() {
            return _this._pos();
          };
        })(this));
        this.model.on("remove", this.remove, this);
      }

      ConnectorView.prototype.events = {
        "mousedown": "_on_mousedown",
        "mouseup": "_on_mouseup"
      };

      ConnectorView.prototype._on_mousedown = function(event) {
        var _ref;
        if ((_ref = this.model.node.graph) != null) {
          _ref.pick_start(this.model);
        }
        return false;
      };

      ConnectorView.prototype._on_mouseup = function(event) {
        var _ref;
        if ((_ref = this.model.node.graph) != null) {
          _ref.pick_end(this.model);
        }
        return false;
      };

      ConnectorView.prototype.restore = function() {
        return this.delegateEvents();
      };

      ConnectorView.prototype.render = function() {
        this.$el.text(this.model.get("title"));
        return this;
      };

      return ConnectorView;

    })(Backbone.View);
    views.LeftConnectorView = (function(_super) {
      __extends(LeftConnectorView, _super);

      function LeftConnectorView() {
        return LeftConnectorView.__super__.constructor.apply(this, arguments);
      }

      LeftConnectorView.prototype.className = 'connector ui-state-default ui-corner-left';

      LeftConnectorView.prototype._pos = function() {
        var pos, x0, x1, y0, y1;
        pos = this.$el.offset();
        x0 = pos.left;
        if (this.connections > 0) {
          x0 -= 5;
        }
        y0 = pos.top + this.$el.outerHeight() / 2;
        x1 = x0 - 50;
        y1 = y0;
        return new math.Segment(new math.Vector(x0, y0), new math.Vector(x1, y1));
      };

      LeftConnectorView.prototype.draw = function(graph) {
        var ctx, pos, x, y;
        if (this.connections > 0) {
          pos = this.$el.offset();
          x = pos.left;
          y = pos.top + this.$el.outerHeight() / 2;
          ctx = graph.context;
          ctx.strokeStyle = "rgb(0,0,0)";
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x - 10, y - 6);
          ctx.lineTo(x - 10, y + 6);
          ctx.lineTo(x, y);
          return ctx.fill();
        }
      };

      return LeftConnectorView;

    })(views.ConnectorView);
    views.RightConnectorView = (function(_super) {
      __extends(RightConnectorView, _super);

      function RightConnectorView() {
        return RightConnectorView.__super__.constructor.apply(this, arguments);
      }

      RightConnectorView.prototype.className = 'connector ui-state-default ui-corner-right';

      RightConnectorView.prototype._pos = function() {
        var pos, x0, x1, y0, y1;
        pos = this.$el.offset();
        x0 = pos.left + this.$el.outerWidth();
        y0 = pos.top + this.$el.outerHeight() / 2;
        x1 = x0 + 50;
        y1 = y0;
        return new math.Segment(new math.Vector(x0, y0), new math.Vector(x1, y1));
      };

      return RightConnectorView;

    })(views.ConnectorView);
    return views.ConnectionsView = (function(_super) {
      __extends(ConnectionsView, _super);

      function ConnectionsView(options) {
        ConnectionsView.__super__.constructor.call(this, options);
        this.model.on('add', this._add, this);
        this.model.on('reset', this._reset, this);
        this.connections = [];
      }

      ConnectionsView.prototype._reset = function() {
        return this.model.forEach(this._add, this);
      };

      ConnectionsView.prototype._add = function(item) {
        var gizmo, removeOne;
        gizmo = new gizmos.EdgeGizmo(item.get("start"), item.get("end"));
        removeOne = function(item, collection) {
          var index;
          if (collection !== this.model) {
            return;
          }
          index = this.connections.indexOf(gizmo);
          if (index >= 0) {
            this.connections.splice(index, 1);
          }
          return item.off("remove", null, this);
        };
        item.on("remove", removeOne, this);
        return this.connections.push(gizmo);
      };

      ConnectionsView.prototype.render_canvas = function(ctx) {
        var conn, _i, _len, _ref;
        ctx.strokeStyle = "rgb(0,0,0)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        _ref = this.connections;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          conn = _ref[_i];
          conn.draw(ctx);
        }
        return ctx.stroke();
      };

      return ConnectionsView;

    })(Backbone.View);
  });

}).call(this);
